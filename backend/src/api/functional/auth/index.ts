/**
 * @packageDocumentation
 * @module api.functional.auth
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
//================================================================
import type { IConnection } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import type { Primitive, Resolved } from "typia";
import typia from "typia";

import type { ILogoutResponse, IUserResponse } from "../../../modules/auth/dto";

export * as telegram from "./telegram/index";

/**
 * Logout user
 *
 * Logs out the user. Client should discard the JWT token.
 *
 * @tag auth
 * @security bearer
 * @returns Logout success status
 *
 * @controller AuthController.logout
 * @path POST /auth/logout
 * @accessor api.functional.auth.logout
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function logout(connection: IConnection): Promise<logout.Output> {
  return true === connection.simulate
    ? logout.simulate(connection)
    : PlainFetcher.fetch(connection, {
        ...logout.METADATA,
        template: logout.METADATA.path,
        path: logout.path(),
      });
}
export namespace logout {
  export type Output = Primitive<ILogoutResponse>;

  export const METADATA = {
    method: "POST",
    path: "/auth/logout",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: 201,
  } as const;

  export const path = () => "/auth/logout";
  export const random = (): Resolved<Primitive<ILogoutResponse>> =>
    typia.random<Primitive<ILogoutResponse>>();
  export const simulate = (_connection: IConnection): Output => {
    return random();
  };
}

/**
 * Get current user
 *
 * Returns the currently authenticated user based on JWT token.
 *
 * @tag auth
 * @security bearer
 * @returns Current user data
 *
 * @controller AuthController.me
 * @path GET /auth/me
 * @accessor api.functional.auth.me
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function me(connection: IConnection): Promise<me.Output> {
  return true === connection.simulate
    ? me.simulate(connection)
    : PlainFetcher.fetch(connection, {
        ...me.METADATA,
        template: me.METADATA.path,
        path: me.path(),
      });
}
export namespace me {
  export type Output = Primitive<IUserResponse | null>;

  export const METADATA = {
    method: "GET",
    path: "/auth/me",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: 200,
  } as const;

  export const path = () => "/auth/me";
  export const random = (): Resolved<Primitive<IUserResponse | null>> =>
    typia.random<Primitive<IUserResponse | null>>();
  export const simulate = (_connection: IConnection): Output => {
    return random();
  };
}
