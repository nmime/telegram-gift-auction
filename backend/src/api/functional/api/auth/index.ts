/**
 * @packageDocumentation
 * @module api.functional.api.auth
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
//================================================================
import type { IConnection } from "@nestia/fetcher";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import type { Primitive, Resolved } from "typia";
import typia from "typia";

import type {
  ILogin,
  ILoginResponse,
  ILogoutResponse,
  IUserResponse,
} from "../../../../modules/auth/dto";

export * as telegram from "./telegram/index";

/**
 * Login or register user
 *
 * Authenticates a user by username. Creates a new user if the username does not exist.
 * Returns JWT access token.
 *
 * @param body Login credentials
 * @tag auth
 * @returns Login response with user data and access token
 *
 * @controller AuthController.login
 * @path POST /api/auth/login
 * @accessor api.functional.api.auth.login
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function login(
  connection: IConnection,
  body: login.Body,
): Promise<login.Output> {
  return true === connection.simulate
    ? login.simulate(connection, body)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...login.METADATA,
          template: login.METADATA.path,
          path: login.path(),
        },
        body,
      );
}
export namespace login {
  export type Body = Primitive<ILogin>;
  export type Output = Primitive<ILoginResponse>;

  export const METADATA = {
    method: "POST",
    path: "/api/auth/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: 201,
  } as const;

  export const path = () => "/api/auth/login";
  export const random = (): Resolved<Primitive<ILoginResponse>> =>
    typia.random<Primitive<ILoginResponse>>();
  export const simulate = (connection: IConnection, body: Body): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: path(),
      contentType: "application/json",
    });
    assert.body(() => typia.assert(body));
    return random();
  };
}

/**
 * Logout user
 *
 * Logs out the user. Client should discard the JWT token.
 *
 * @tag auth
 * @security bearer
 * @returns Logout success status
 *
 * @controller AuthController.logout
 * @path POST /api/auth/logout
 * @accessor api.functional.api.auth.logout
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function logout(connection: IConnection): Promise<logout.Output> {
  return true === connection.simulate
    ? logout.simulate(connection)
    : PlainFetcher.fetch(connection, {
        ...logout.METADATA,
        template: logout.METADATA.path,
        path: logout.path(),
      });
}
export namespace logout {
  export type Output = Primitive<ILogoutResponse>;

  export const METADATA = {
    method: "POST",
    path: "/api/auth/logout",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: 201,
  } as const;

  export const path = () => "/api/auth/logout";
  export const random = (): Resolved<Primitive<ILogoutResponse>> =>
    typia.random<Primitive<ILogoutResponse>>();
  export const simulate = (_connection: IConnection): Output => {
    return random();
  };
}

/**
 * Get current user
 *
 * Returns the currently authenticated user based on JWT token.
 *
 * @tag auth
 * @security bearer
 * @returns Current user data
 *
 * @controller AuthController.me
 * @path GET /api/auth/me
 * @accessor api.functional.api.auth.me
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function me(connection: IConnection): Promise<me.Output> {
  return true === connection.simulate
    ? me.simulate(connection)
    : PlainFetcher.fetch(connection, {
        ...me.METADATA,
        template: me.METADATA.path,
        path: me.path(),
      });
}
export namespace me {
  export type Output = Primitive<IUserResponse | null>;

  export const METADATA = {
    method: "GET",
    path: "/api/auth/me",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: 200,
  } as const;

  export const path = () => "/api/auth/me";
  export const random = (): Resolved<Primitive<IUserResponse | null>> =>
    typia.random<Primitive<IUserResponse | null>>();
  export const simulate = (_connection: IConnection): Output => {
    return random();
  };
}
