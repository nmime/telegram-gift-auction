# Конкурентность и безопасность

[← К README](../../README.ru.md) · [Архитектура](./architecture.md) · [API](./api.md) · [Тестирование](./testing.md) · [Деплой](./deployment.md)

---

## Проблема

Аукционные системы сталкиваются с экстремальными проблемами конкурентности:
- Множество пользователей делают ставки одновременно
- Один пользователь отправляет запросы в быстрой последовательности
- Сетевые повторы вызывают дублирование
- Race conditions при переходах между раундами
- Попытки манипуляции балансом
- Несколько инстансов сервера транслируют таймеры

Наивная реализация быстро приведёт к:
- Двойным тратам (ставка одними деньгами дважды)
- Отрицательным балансам
- Дублирующим ставкам
- Потерянным транзакциям
- Повреждённому состоянию аукциона
- Дублирующим трансляциям таймеров

## 5-уровневая модель защиты

Мы реализуем защиту в глубину с 5 независимыми уровнями:

```
┌─────────────────────────────────────────────────────────┐
│                    HTTP запрос                           │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│  Уровень 1: Распределённая блокировка (Redlock)          │
│  ─────────────────────────────────────────────────────  │
│  • Захват блокировки для комбинации пользователь+аукцион │
│  • Режим fail-fast (без ожидания)                        │
│  • TTL 10 секунд (авто-освобождение при сбое)           │
│  • Предотвращает параллельные запросы от одного юзера   │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│  Уровень 2: Redis Cooldown                               │
│  ─────────────────────────────────────────────────────  │
│  • 1-секундный кулдаун между ставками на юзера/аукцион  │
│  • Предотвращает спам и случайные двойные клики         │
│  • Лёгкая проверка перед дорогими операциями            │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│  Уровень 3: MongoDB транзакция                           │
│  ─────────────────────────────────────────────────────  │
│  • Уровень изоляции Snapshot                             │
│  • Write concern majority                                │
│  • Автоматический retry при временных ошибках           │
│  • Семантика «всё или ничего» для финансовых операций   │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│  Уровень 4: Оптимистичная блокировка                     │
│  ─────────────────────────────────────────────────────  │
│  • Поле version в документах пользователей               │
│  • Проверка соответствия версии ожидаемому значению     │
│  • Обнаружение параллельных модификаций                 │
│  • Сбой, если другой запрос изменил данные первым       │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│  Уровень 5: Уникальные индексы                           │
│  ─────────────────────────────────────────────────────  │
│  • Уникальный индекс: (auctionId, odId, status='active')│
│  • Уникальный индекс: (auctionId, amount)                │
│  • Обеспечение на уровне базы данных                    │
│  • Последняя линия защиты от дубликатов                 │
└─────────────────────────────────────────────────────────┘
```

## Redis выборы лидера для таймеров

При multi-server деплое только один сервер должен транслировать таймеры обратного отсчёта, чтобы избежать дублирования событий.

### Реализация

```typescript
// TimerService использует Redis ключ с TTL для выборов лидера
const LEADER_KEY = 'timer-service:leader';
const LEADER_TTL = 5; // секунд

async tryBecomeLeader(): Promise<boolean> {
  // SET NX с TTL - успешно только если ключ не существует
  const result = await redis.set(LEADER_KEY, this.serverId, 'NX', 'EX', LEADER_TTL);
  return result === 'OK';
}

async refreshLeadership(): Promise<boolean> {
  // Обновляем только если мы текущий лидер
  const currentLeader = await redis.get(LEADER_KEY);
  if (currentLeader === this.serverId) {
    await redis.expire(LEADER_KEY, LEADER_TTL);
    return true;
  }
  return false;
}
```

### Обязанности лидера

- Трансляция событий `countdown` каждую секунду
- Обработка распространения анти-снайпинг продлений
- Координация переходов раундов

### Отказоустойчивость

Если лидер падает, ключ истекает через 5 секунд, и другой сервер автоматически становится лидером.

## Ультра-быстрый путь ставки (Redis Lua скрипт)

Для максимальной пропускной способности система предоставляет ультра-быстрый путь ставок, который обходит 5-уровневую модель защиты в пользу единого атомарного Lua скрипта:

```
┌─────────────────────────────────────────────────────────┐
│                    HTTP запрос                           │
│                POST /auctions/:id/fast-bid               │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│  Единый Lua скрипт (Атомарный, ~0.02мс)                 │
│  ─────────────────────────────────────────────────────  │
│  1. Проверка статуса аукциона из кэша                   │
│  2. Проверка тайминга раунда (не истёк ли)              │
│  3. Валидация баланса пользователя из Redis hash        │
│  4. Обработка существующей ставки (возврат заморозки)   │
│  5. Заморозка новой суммы ставки                        │
│  6. Обновление ZSET лидерборда с encoded score          │
│  7. Пометка баланса и ставки как dirty для синхронизации│
│  8. Возврат успеха с суммами                            │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│  Асинхронные операции (Неблокирующие)                   │
│  ─────────────────────────────────────────────────────  │
│  • WebSocket событие new-bid                            │
│  • Проверка анти-снайпинга (продление раунда)           │
│  • Уведомления о перебитии                              │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│  Фоновая синхронизация (Каждые 5 секунд)                │
│  ─────────────────────────────────────────────────────  │
│  • Запись dirty балансов в MongoDB                      │
│  • Запись dirty ставок в MongoDB                        │
│  • Очистка dirty флагов                                 │
└─────────────────────────────────────────────────────────┘
```

### Сравнение производительности

| Метрика | Стандартный (5 уровней) | Ультра-быстрый (Lua) |
|---------|------------------------|----------------------|
| Латентность | ~50-100мс | ~2мс |
| Пропускная способность | ~20 ставок/сек | 2,500+ ставок/сек |
| Консистентность | Немедленная | Eventual (5с синхр.) |
| Защита | Полный ACID | Атомарный Lua + Dirty Tracking |

### Когда использовать каждый путь

- **Стандартный путь** (`POST /auctions/:id/bid`): Когда требуется строгая консистентность, аукционы с низким трафиком
- **Ультра-быстрый путь** (`POST /auctions/:id/fast-bid`): Высокий трафик, когда допустима eventual консистентность 5 секунд

---

## Стандартный поток ставки (5-уровневая защита)

```typescript
POST /api/auctions/:id/bid { amount: 1000 }

// Уровень 1: Распределённая блокировка
const lockKey = `bid:${auctionId}:${odId}`;
const lock = await redlock.acquire([lockKey], 10000, {
  retryCount: 0  // fail-fast, не ждём
});

try {
  // Уровень 2: Redis Cooldown
  const cooldownKey = `cooldown:${auctionId}:${odId}`;
  const hasCooldown = await redis.get(cooldownKey);
  if (hasCooldown) {
    throw new TooManyRequestsException('Подождите перед следующей ставкой');
  }

  // Уровень 3: MongoDB транзакция
  const session = await mongoose.startSession();
  session.startTransaction({
    readConcern: { level: 'snapshot' },
    writeConcern: { w: 'majority' }
  });

  try {
    // Уровень 4: Оптимистичная блокировка
    const user = await User.findById(odId).session(session);
    const expectedVersion = user.version;

    // Выполнение логики ставки...
    const updateResult = await User.updateOne(
      { _id: odId, version: expectedVersion },
      { $inc: { balance: -amount, frozenBalance: amount, version: 1 } }
    ).session(session);

    if (updateResult.modifiedCount === 0) {
      throw new ConflictException('Обнаружена параллельная модификация');
    }

    // Уровень 5: Уникальный индекс (обеспечивается MongoDB)
    await Bid.create([{ auctionId, odId, amount, status: 'active' }], { session });

    await session.commitTransaction();

    // Обновление Redis лидерборда
    await leaderboardService.addBid(auctionId, odId, amount, createdAt);

    // Установка кулдауна после успеха
    await redis.setex(cooldownKey, 1, '1');

  } catch (error) {
    await session.abortTransaction();
    throw error;
  }
} finally {
  await lock.release();
}
```

## Обработанные краевые случаи

| Краевой случай | Уровень защиты | Поведение |
|----------------|----------------|-----------|
| 10 параллельных ставок от одного юзера | Redlock | Только 1 проходит, 9 — fail fast |
| Быстрые клики | Redis cooldown | Отклонено со статусом 429 |
| Сбой сервера посреди транзакции | MongoDB транзакция | Автоматический откат |
| Два пользователя ставят одну сумму | Уникальный индекс | Вторая ставка отклонена |
| Race condition баланса | Оптимистичная блокировка | Retry или сбой |
| Устаревшее чтение при переходе раунда | Snapshot isolation | Консистентное представление |
| Несколько серверов транслируют таймеры | Выборы лидера | Только лидер транслирует |
| Лидер-сервер падает | Истечение TTL | Новый лидер выбран за 5с |

## Защита баланса

Операции с балансом используют атомарные операторы MongoDB с защитой:

```typescript
// Списание баланса (только при достаточных средствах)
await User.updateOne(
  {
    _id: odId,
    balance: { $gte: amount }  // Защита: должны быть средства
  },
  {
    $inc: {
      balance: -amount,
      frozenBalance: amount
    }
  }
);

// Защита на уровне схемы
const userSchema = new Schema({
  balance: { type: Number, min: 0 },       // Не может стать отрицательным
  frozenBalance: { type: Number, min: 0 }  // Не может стать отрицательным
});
```

## Консистентность лидерборда

Операции Redis ZSET атомарны, но нужна консистентность с MongoDB:

```typescript
// При успешной ставке (внутри транзакции)
1. MongoDB: Создание/обновление документа ставки
2. Redis: ZADD в лидерборд

// При завершении раунда
1. MongoDB: Обновление статуса ставки на 'won'
2. Redis: ZREM из лидерборда

// Fallback
Если Redis недоступен, getLeaderboard() переключается на MongoDB запрос
```

## Проверка финансовой целостности

Система включает эндпоинт проверки:

```typescript
// Инвариант, который всегда должен соблюдаться:
totalDeposits - totalWithdrawals =
  sum(user.balance) + sum(user.frozenBalance) + totalSpentOnWins

// Проверка по запросу через API
GET /api/transactions/verify-integrity
// Возвращает: { valid: true, difference: 0 }
```

## Распределённое масштабирование

Для multi-server деплойментов:

1. **Redlock** использует Redis для распределённых блокировок
2. **Выборы лидера** обеспечивают единственного транслятора таймеров
3. **Socket.IO Redis adapter** транслирует события между серверами
4. **ZSET лидерборд** общий для всех инстансов
5. **MongoDB replica set** обеспечивает консистентность данных
6. **Stateless JWT auth** позволяет направлять запросы на любой сервер

```yaml
# docker-compose.yml для масштабирования
services:
  backend:
    deploy:
      replicas: 3
    depends_on:
      - redis
      - mongodb
```

Все инстансы разделяют:
- Redis лидерборды (ZSET)
- Redis блокировки и кулдауны
- Redis ключ выборов лидера
- Данные MongoDB
- WebSocket события (через Redis adapter)
